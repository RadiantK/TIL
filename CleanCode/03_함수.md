# 03.함수(Function)

### **작게 만들어라!**

함수의 라인 수는 작을수록 좋다.  
<br/>

**블록과 들여쓰기**

if/else문이나 while문에 들어가는 블록은 한 줄이어야 한다.  

블록안에서 메서드를 호출하여 코드를 이해하기 쉽도록 구성

함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.  
<br/>

```java
public boolean function() {
	if( 조건 ) {
		// 메서드호출
		return true;
	}
	return false;
}
```
<br/>

### **한 가지만 해라!**

함수는 한 가지를 해야 하며, 그 한 가지를 잘 해야 한다.  
<br/>

**함수가 ‘한 가지’만 하는지 판단하는 방법**

\- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.

\- 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 것이다.  
<br/>

### **함수 당 추상화 수준은 하나로**

함수가 확실히 ‘한 가지’ 작업만  하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.  

추상화 수준함수의 디테일이 커질 수록 추상화가 높은 함수(함수 안에서 다른 기능을 함수로 구현)  
<br/>

**위에서 아래로 코드 읽기내려가기 규칙**

코드는 위에서 아래로 이야기처럼 읽혀야 좋다.

위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아지는 것이다.  
<br/>


### **Swithch 문**

```java
public Money calculatePay(Employee e) throws InvalidEmployeeType {
	switch (e.type) {
		case COMMISSIONreturn calculateCommissionedPay(e);
		case HOURLYreturn calculateHourlyPay(e);
		case SALARIEDreturn calculateSalariedPay(e);
		defaultthrow new InvalidEmployeeType(e.type);
	}
}
```
<br/>

스위치 문은 문제가 존재한다.

1. 함수가 길다.(새 유형 추가 시 더 길어짐)
2. ‘한 가지’ 작업을 수행하지 않는다.
3. 단일 책임 원칙(SRP)을 위반한다.(코드를 변경할 이유가 여러 개)
4. 개방 폐쇄 원칙(OCP)를 위반한다.(새 직원 유형을 추가할 때마다 코드를 변경해야 함)
5. 가장 큰 문제는 위의 함수와 구조가 동일한 함수가 무한정 존재한다.
<br/>

이 문제를 해결하기 위해서는 switch문을 추상 팩토리에 숨기고 인터페이스를 거쳐서 호출 될 수 있도록 한다.  
<br/>

### **서술적인 이름을 사용하라.**

함수가 작고 단순할수록 서술적인 이름을 고르기도 쉬워진다.

이름을 정하느라 시간이 많이 투자되고 길어지더라도 이름짓는 것이 중요(IDE의 자동완성 기능도 활용)

서술적인 이름을 사용하면 개발자의 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.

이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.  
<br/>

### **함수 인수**

함수에서 가장 이상적인 인수 개수는 0개(무항)이다.(항이 적을 수록  좋음)
<br/>

**많이 쓰는 단항 형식**

```java
// 인수에게 질문을 던지는 예
boolean fileExists("MyFile")

// 인수를 무엇인 가로 변환해 결과를 반환하는 경우
InputStream fileOpen("MyFile")
```
<br/>

이벤트 함수도 드물게 사용되지만 이벤트라는 사실이 코드에 명확히 드러나야 한다.

위의 경우가 아니라면 단항 함수는 가급적 피하는 것이 좋다.

입력 인수를 변환하는 함수라면 변환 결과를 반환값으로 돌려준다.

입력 인수를 그대로 돌려주는 함수라 할지라도 변환 함수 형식을 따르는 편이 좋다. 적어도 변환 형태는 유지하기 때문이다.  
<br/>

**플래그 인수**

함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 것이니 쓰지 않는 것이 좋다.  
<br/>

**이항 함수**

단항 함수보다 이해하기 어렵다.

Point p = new Point(0, 0)처럼 좌표계를 사용하여 자연스럽게 사용되는 경우가 아니라면 단항이나 무항 함수를 더 지향한다.  
<br/>

**삼항 함수**

삼항 함수는 이항 함수보다 더 이해하기 어렵다. 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다. 사용 시 신중히 고려하라 권고한다.
<br/>

**인수 객체**

인수가 2~3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
<br/>

**인수 목록**

인수 개수가 가변적인 함수도 필요하다.(String.format(String format, Object… args)

가변 인수를 전부 동등하게 취급하면 List 형 인수 하나로 취급할 수 있다.

가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있지만, 이를 넘어서는 인수를 사용할 경우에는 문제가 있다.  
<br/>

**동사와 키워드**

함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.  
<br/>

### **부수 효과를 일으키지 마라!**

함수에서 한 가지를 하겠다고 약속하고선 남 몰래 다른 짓을 하는 부수 효과를 일으켜선 안된다.  
<br/>

**출력 인수**

일반적으로 우리는 인수를 함수 입력으로 해석하기 때문에 출력 인수는 피해야 한다.  
<br/>

### **명령과 조회를 분리하라!**

함수는 무엇인 가를 수행하거나 무엇인 가에 답하거나 둘 중 하나만 해야한다.   
<br/>

### **오류 코드보다 예외를 사용하라!**

명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.

오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제에 부딪힌다.

반면 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.  
<br/>

**Try/Catch 블록 뽑아내기**

try/catch 블록은 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞기 때문에 별도 함수로 뽑아내는 것이 좋다.  
<br/>

```java
public void delete(Page page) {
	try {
		deletePageAndAllReference(page);
	} catch (Exception e) {
		logError(e);
	}
}
```
<br/>

**오류 처리도 한 가지 작업이다**

함수는 한 가지 작업만 해야 하는데 오류 처리도 한 가지 작업이므로 오류를 처리하는 함수는 오류만 처리해야 한다.  
<br/>

**Error.java 의존성 자석**

만약 자바에서 Error 코드를 위한 Enum을 사용한다고 했을 때, 다른 클래스에서 Error enum을 사용해야 하므로 Error enum이 변경된다면, Error enum을 사용하는 클래스 전부를 다시 컴파일하고 다시 배치해야 한다.  

하지만 예외를 사용한다면 재컴파일/재배치 없이도 새 예외 클래스를 추가해서 사용할 수 있기 때문에 예외를 권장하는 것 이다.  
<br/>

### **반복하지 마라!**

코드의 중복은 코드 길이가 늘어날 뿐만 아니라 알고리즘이 변하면 수정할 곳이 늘어나므로 문제가 된다. 거기에 어느 한 곳이라도 빠뜨리게 되면 오류가 발생할 확률도 증가한다.

중복은 소프트웨어에서 모든 악의 근원이므로 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다.

- 자료에서 중복을 제거할 목적으로 RDBMS의 정규 형식을 만듬
- 객체지향 프로그래밍은 코드를 부모 클래스로 몰아 중복을 없앤다.
- 구조적 프로그래밍, AOP(Aspect Oriented Programming), COP(Component Oriented Programming)는 어떤 면에서 중복 제거 전략이다.  
- <br/>

### **구조적 프로그래밍**

에츠허르 데이크스트라의 구조적 프로그래밍 원칙은 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다고 했다. 즉, 함수는 return 문이 하나여야 하며 루프 안에서 break나 continue를 사용해선 안되며 goto는 절대로 안된다는 것이다.

위의 규칙은 함수가 아주 클 때만 상당한 이익을 제공하므로 함수를 작게 만든다면 return, break, continue를 여러차례 사용해도 괜찮다. 반면 goto문은 큰 함수에서만 의미가 있으므로, 작은 함수에서는 피해야만 한다.  
<br/>

### **함수를 어떻게 짜죠?**

처음부터 함수를 완벽하게 짜내는 것은 매우 힘들다.

처음 작성한 복잡하고 중복이 많은 코드에서 테스트를 진행하고, 그런 다음에 코드를 다듬고, 함수를 만들고, 이름을 바꾸고, 중복을 제거하며, 메서드를 줄이고 순서를 바꾼다. 때로는 전체 클래스를 쪼개기도 하며 함수를 리팩토링 한다.

이 과정에서도 단위 테스트는 항상 통과해야 한다.  
<br/>

### **3장 함수를 마치며…**

처음부터 함수를 완벽하게 만드는 것은 불가능하다고 생각한다.

처음 만들어진 초안의 함수를 3장에서 나온 좋은 토대들로 리팩토링하며 단위 테스트를 진행하면 깔끔한 함수를 완성할 수 있을 것이라고 생각한다.  
<br/>
<br/>