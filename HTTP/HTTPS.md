# 보안 HTTP

## HTTP를 안전하게 만들기
HTTP의 보안 버전은 효율적이고, 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아야 한다. 또한 사회와 정부의 요구사항에도 맞아야 한다.  
<br/>

HTTP 보안 기술이 제공해줘야 하는 것들  
- 서버 인증 : 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알아야 한다.
- 무결성 : 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화 : 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율 : 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
- 편재성(Ubiquity) : 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 적응성 : 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성 : 사회적 문화적, 정치적 요구를 만족시켜야 한다.  
<br/>
<br/>

### HTTPS
넷스케이프 커뮤니케이션 주식회사(Netscape Communication Corpaoration)에서 개척했다.  
웹 페이지가 HTTPS로 접근 하는 경우 URI Scheme을 통해서 확인할 수 있다.  
HTTPS를 사용할 때, 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.   
HTTPS는 HTTP 하부에 전송 레벨 암호 보안 계층을 제공함으로써 동작하는데, 이 보안 계층은 안전 소켓 계층(Secure Sockets Layer, SSL) 혹은 그를 계승한 전송 계층 보안(Transport Layer Security, TLS)을 이용하여 구현된다.  
<br/>

![Untitled (1)](https://user-images.githubusercontent.com/95058915/235281818-430bfb91-f460-4709-8d53-c46063c7a5c7.png)
<br/>

어려운 인코딩 및 디코딩 작업은 대부분의 SSL 라이브러리 안에서 일어나기 때문에, 보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다. 대부분 TCP 입력과 출력 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하면 된다.  
<br/>
<br/>

## 디지털 암호학
- 암호 : 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키 : 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계 : 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계 : 인코딩과 디코딩에 다른 키를 사용하는 일고리즘
- 공개키 암호법 : 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명 : 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서 : 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보  
<br/>
<br/>

### 비밀 코드의 기술과 과학
암호법(cryptography)은 메시지 인코딩과 디코딩에 대한 과학이자 기술(art) 이다.  
암호법은 메시지 암호화나 메시지의 변조 방지를 위해 사용될 수 있고, 누군가가 어떤 메시지나 트랜잭션의 저자임을 증명하는 데도 사용될 수 있다.  
<br/>
<br/>

### 암호(cipher)
암호법은 암호라는 비밀 코드에 기반한다.  
암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다. 인코딩 전의 메시지는 평문, 인코딩된 메시지는 암호문이라고 불린다.  
<br/>
<br/>

### 암호 기계
기술의 진보로, 사람들은 보다 복잡한 암호로 메시지를 빠르고 정확하게 인코딩하는 기계를 만들기 시작했다. 기계는 암호화를 깨뜨리기 어렵게 했다.  
<br/>
<br/>

### 키가 있는 암호
대부분의 암호 기계들에는 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 달려있다. 기계가 훔쳐져도, 올바른 다이얼 설정(키 값)이 없이는 디코더가 동작하지 않는다.  
이러한 암호 매개변수를 키라고 부르며, 암호 키는 하나의 암호 기계를 여러가지 가상 암호 기계의 집합처럼 만들어 준다. 이 가상 암호 기계들은 서로 다른 키 값을 갖고 있기 때문에 제각각 다르게 동작한다.  
<br/>

![Untitled (2)](https://user-images.githubusercontent.com/95058915/235281842-a359b24f-8e66-4262-a7ae-a7414ec5175d.png)
<br/>
<br/>

### 디지털 암호

디지털 계산의 도래로 인한 발전  
- 속도 및 기능에 대한 장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.  
- 매우 큰 키를 지원하는 것이 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조 개의 가상 암호 알고리즘을 만들 수 있게 됐다. 키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 키에 의한 크래킹이 어려워진다.  
<br/>

디지털 키는 숫자에 불과하며, 디지털 키 값은 인코딩과 디코딩 알고리즘에 대한 입력 값이다. 코딩 알고리즘은 데이터 덩어리를 받아서 알고리즘과 키의 값에 근거하여 인코딩하거나 디코딩하는 함수이다.  
<br/>
<br/>

## 대칭키 암호법
많은 디지털 암호 알고리즘은 대칭키 암호라 불리는데, 인코딩 할 때 사용하는 키가 디코딩을 할 때와 같기 때문이다.   
대칭키 암호에서, 발송자와 수신자 모두 통신을 위해 비밀 키를 똑같이 공유해야 한다. 발송자는 공유된 비밀 키의 메시지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해서 사용한다. 수신자는 역시 암호문을 받은 뒤에 같은 공유된 키를 사용하여 원래의 평문을 복원하기 위해 해독함수를 적용한다.  
<br/>

![Untitled (3)](https://user-images.githubusercontent.com/95058915/235281864-411828a3-6bd3-4fe3-88b7-db7956d97aec.png)
<br/>
<br/>

### 키 길이와 열거 공격(Enumeration Attack)

대부분의 경우, 인코딩 및 디코딩 알고리즘은 공개적으로 알려져 있으므로, 비밀 키는 누설이 되면 안된다.  
좋은 알고리즘은 공격자가 코드를 크래킹(네트워크를 정당한 접근 권한 없이 훼손하거나 정보를 빼내는 것)하려면 모든 키 값을 대입해 시도해보는 것 외에 방법이 없는데, 무차별로 모든 키 값을 대입해보는 공격을 열거 공격이라 한다.  
<br/>

![Untitled (13)](https://user-images.githubusercontent.com/95058915/235282071-ff3349b7-17bf-4c75-98f5-cd8e123bb328.png)
<br/>

<br/>

### 공유키 발급하기
대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 것이다.  
<br/>
<br/>

## 공개키 암호법
한 쌍의 호스트가 하나의 인코딩과 디코딩 키를 사용하는 대신, 공개 키 암호 방식은 두 개의 비대칭 키를 사용한다.  
하나는 호스트의 메시지를 인코딩하기 위한 것이며, 다른 하나는 그 호스트의 메시지를 디코딩하기 위한 것이다.  
인코딩 키는 모두를 위해 공개되어 있다. 하지만 호스트만이 개인 디코딩 키를 알고 있다.  
<br/>

![Untitled (4)](https://user-images.githubusercontent.com/95058915/235281869-94a8b80b-1eee-48ee-bd42-a72257b1680c.png)
<br/>

![Untitled (5)](https://user-images.githubusercontent.com/95058915/235281881-4311115a-253d-4d4b-8290-5c0d886b62bd.png)
<br/>

모든 사람은 소유자의 공캐 키를 가지고 소유자에게 보내는 메시지를 같은 키로 인코딩 할 수 있지만, 소유자만이 디코딩 개인 키를 갖기 때문에 메시지를 디코딩 할 수는 없다.  
키의 분리는, 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지를 디코딩하는 능력은 소유자에게만 부여한다.  
<br/>
<br/>

### RSA

공캐키 비대칭 암호의 과제  
- 공개키(누구든 얻을 수 있다.)
- 가로채서 얻은 암호문의 일부(네트워크를 스누핑해서 획득)
- 메시지와 그것을 암호화한 암호문(인코더에 임의의 텍스트를 넣고 실행해서 획득)  
<br/>

이 모든 요구를 만족하는 공개 키 암호체계중 하나가 RSA 알고리즘 이다.  
<br/>
<br/>

### 혼성 암호 체계와 세션 키
비대칭 공개키 암호방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있게 해주므로 좋지만, 알고리즘의 계산이 느린 경향이 있다.  
실제로는 대칭, 비대칭 방식을 섞은 것이 쓰인다.  노드들 사이의 안전한 의사소통 채널을 수립할 때는 공개 키 암호를 사용하고, 이 후 만들어진 안전한 채널을 통해 나머지 데이터를 암호화 할 때는 대칭키를 사용하는 방식이 쓰인다.  
<br/>
<br/>

### 디지털 서명
암호 체계는 메시지를 암호화하고 해독하는 것 뿐만 아니라, 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록 하는데 이용될 수 있다. 디지털 서명(digital signing)은 인터넷 보안 인증서에서 중요하다.  
<br/>
<br/>

### 서명은 암호 체크섬이다.
디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬으로, 두 가지 이점을 갖는다.  
- 서명은 메시지를 작성한 저자가 누군지 알려준다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다. 체크섬은 저자의 개인 서명처럼 동작한다.
- 서명은 메시지의 위조를 방지한다. 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다. 그리고 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.  
<br/>

디지털 서명은 보통 비대칭 공개키에 의해 생성된다. 개인 키는 오직 소유자만이 알고 있기 때문에 ,저자의 개인 키는 일종의 지문처럼 사용된다.  
<br/>

![Untitled (6)](https://user-images.githubusercontent.com/95058915/235281883-a2441ca8-ed3e-4c2a-81fc-081f5305996d.png)
<br/>
<br/>

## 디지털 인증서
디지털 인증서(certs)는 신뢰할 수 있는 기관으로부터 보증받은 사용자나 회사에 대한 정보를 담고 있다.  
<br/>
<br/>

### 인증서의 내부
디지털 인증서에는 공식적으로 인증 기관에 의해 디지털 서명된 정보의 집합이 담겨있다.  
- 대상의 이름(사람, 서버, 조직 등)
- 유효 기간
- 인증서 발급자(누가 이 인증서를 보증하는가)
- 인증서 발급자의 디지털 서명  
<br/>

디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보 뿐만 아니라 보통 대상의 공개키도 담고 있다.  
<br/>

![Untitled (7)](https://user-images.githubusercontent.com/95058915/235281910-8b4707a2-0935-4978-a3a9-dbb9176920e5.png)
<br/>
<br/>

### X.509 v3 인증서
디지털 인증서에 대한 세계적인 단일 표준은 없고, 여러가지 다른 스타일의 인증서들이 존재한다.   
X.509 v3 인증서는 인증 정보를 파싱 가능한 필드에 넣어 구조화 하는 표준화된 방법을 제공한다.  
<br/>
<br/>

### 서버 인증을 위해 인증서 사용하기
사용자가 HTTP를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다. 서버가 인증서를 갖고 있지 않다면, 보안 커넥션을 실패한다.   
<br/>

서버 인증서의 필드  
- 웹 사이트의 이름과 호스트 명
- 웹 사이트의 공개 키
- 서명 기관의 이름
- 서명 기관의 서명  
<br/>

브라우저가 인증서를 받으면, 서명 기관을 검사하고, 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이며 그 서명을 검증할 수 있다.   
서명 기관이 모르는 곳이라면, 브라우저는 신뢰해야 하는지 확신할 수 없으므로, 사용자의 확인을 위한 대화상자를 보여준다.   
<br/>
<br/>

## HTTPS의 세부사항
HTTPS는 HTTP의 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다. 이 기법들의 집합은 무정부 상태의 분권화된 글로벌 인터넷 환경에서도 HTTPS를 매우 안전한 동시에 매우 유연하고 관리하기 쉽게 만들어 준다.  
<br/>
<br/>

### HTTP의 개요
HTTPS는 보안 전송 계층을 통해 전송되는 HTTP이다. 암호화 되지 않은 HTTP메시지를 TCP를 통해 전 세계의 인터넷으 곳곳으로 보내는 대신에, HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다.  
<br/>

![Untitled (8)](https://user-images.githubusercontent.com/95058915/235281920-d0c043b1-008b-44e5-949c-da7f730b66bd.png)
<br/>
<br/>

### HTTPS 스킴
보안 HTTP는 선택적이다. 웹 서버에게 요청을 만들 때, 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요한데 URL의 스킴을 통해 이루어진다.  
<br/>

```bash
http://
https://
```
<br/>

- URL이 http 스킴을 갖고 있다면, 클라이언트는 서버에 80번 포트로 연결하고 평범한 HTTP 명령을 전송한다.
- URL이 https 스킴을 갖고 있다면, 클라이언트는 서버에 443 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 핸드셰이크를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.  
<br/>

![Untitled (9)](https://user-images.githubusercontent.com/95058915/235281951-4331f162-e57e-4350-bbc0-be1a7908e2b2.png)
<br/>

SSL 트래픽은 바이너리 프로토콜이기 때문에 HTTP와는 완전 다르며, 트래픽은 다른 포트(보통 443)로 전달된다.  
<br/>
<br/>

### 보안 전송 셋업
암호화 되지 않은 HTTP에서 클라이언트는 웹 서버의 80번 포트로 TCP 커넥션을 열고, 요청 메시지를 보내고, 응답 메시지를 받고, 커넥션을 닫는다.  
HTTPS 에서는 클라이언트는 먼저 웹 서버의 443포트로 연결한다. 일단 TCP연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL계층을 초기화한다. 핸드셰이크가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다. 이 메시지는 TCP로 보내기 전에 암호화된다.  
<br/>

![Untitled (10)](https://user-images.githubusercontent.com/95058915/235281966-c1cef532-bc46-48d2-b2fe-e768c11ea598.png)
<br/>
<br/>

### SSL 핸드셰이크
암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트는 서버와 SSL 핸드셰이크를 할 필요가 있다.  
- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성  
<br/>

암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고 받는다.  
<br/>

![Untitled (14)](https://user-images.githubusercontent.com/95058915/235282174-1d684fc9-7e89-4eed-b3ec-7abe857c20b5.png)
<br/>
<br/>

### 서버 인증서
SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다.   
오늘날은 클라이언트 인증서는 잘 쓰이지 않으며 , 대부분의 사용자는 개인 클라이언트 인증서를 갖고 있지도 않는다.  
보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다. 잘 알려진 인증기관에 의해 서명된 서버 인증서는, 그가 서버에 그의 신용카드나 개인 정보를 보내기 전에 그 서버를 얼마나 신뢰할 수 있는지 평가하는 것을 도와줄 것이다.  
서버 인증서는 조직의 이름, 주소 서버의 DNS 도메인 이름, 그리고 그 외의 정보를 보여주는 X.509 v3에서 파생된 인증서이다. 사용자와 사용자의 클라이언트 수프트웨어는 모든 것이 믿을만한 것인지 확인하기 위해서 인증서를 검증할 수 있다.  
<br/>
<br/>

### 사이트 인증서 검사
SSL 자체는 사용자에게 웹 서버 인증서를 검증할 것을 요구하지 않지만, 최신 웹 브라우저들은 대부분은 인증서에 대해 간단하게 기본적인 검사를 하고 그 결과를 철저한 검사를 할 수 있는 방법과 함께 사용자에게 알려준다.  
넷스케이프가 제안한 웹 서버의 인증서 검사를 위한 알고리즘은 대부분의 웹 브라우저 검사 기법의 기초를 구축했다.  
<br/>

**날짜 검사**  
브라우저는 인증서가 여전히 유효함을 확인하기 위해 인증서의 시작 및 종료일을 검사한다.  
인증서가 만료되었거나 아직 활성화 되지 않았다면, 인증서 검사는 실패하고 브라우저는 에러를 보여준다.  
<br/>

**서명자 신뢰도 검사**   
모든 인증서는 서버를 보증하는 어떤 인증 기관(Certificate Authority, CA)에 의해 서명되어 있다.  
여러가지 수준의 인증서가 있는데, 각각은 다른 수준의 배경 검증을 요구한다. 예를 들어 전자 상거래 서버 인증서를 발급받고자 한다면, 사업체로서의 법인에 대한 법적 증명을 제시해야 한다.  
<br/>

**서명 검사**  
한번 서명 기관이 믿을만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.  
<br/>

**사이트 신원 검사**  
서버가 누군가 다른 이의 인증서를 복사하거나 그들의 트래픽을 가로채는 것을 방지하기 위해, 대부분의 브라우저는 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.  
<br/>
<br/>

### 가상 호스팅과 인증서
가상 호스트(하나의 서버에 여러 호스트 명)로 운영되는 사이트 보안 트래픽을 다루는 것은 까다로운 경우도 많다. 몇몇 인기 있는 웹 서버 프로그램은 오직 하나의 인정서만을 지원한다. 만약 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트 명에 도착했다면 경고 상자가 나타날 것이다.   
<br/>
<br/>

## 진짜 HTTPS 클라이언트
SSL은 복잡한 바이너리 프로토콜이다. SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 혹은 오픈 소스 라이브러리들이 존재한다.  
<br/>
<br/>

### OpenSSL
SSL과 TLS의 가장 인기 있는 오픈 소스 구현이다.  
OpenSSL 프로젝트는, 강력한 다목적 암호법 라이브러리인 동시에 SSL과 TLS 프로토콜을 구현한 강건하고 완전한 기능을 갖춘 사용 수준의 툴킷을 개발하고자 한 자원봉사자들이 협업한 결과물이다.   
<br/>
<br/>

## 프록시를 통한 보안 트래픽 터널링
클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프록시 서버를 이용한다.  
<br/>

![Untitled (11)](https://user-images.githubusercontent.com/95058915/235281974-899935df-108f-48e1-bd95-8a61faae5661.png)
<br/>

하지만 클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화하기 시작했다면, 프록시는 더 이상 HTTP 헤더를 읽을 수 없다. 그리고 만약 프록시가 HTTP 헤더를 읽을 수 없다면, 프록시는 요청을 어디로 보내야 하는지 알 수 없게 된다.  
<br/>

![Untitled (12)](https://user-images.githubusercontent.com/95058915/235281982-f6dff999-fc1b-40f8-b715-b1513a9c0400.png)
<br/>

HTTPS가 프록시와도 잘 동작할 수 있게 하기 위해, 클라이언트가 프록시가 어디에 접속하려고 하는지 말해주는 방법을 약간 수정해야 한다. 이 때 사용하는 기법 하나가 HTTPS SSL 터널링 프로토콜이다.  
HTTPS 터널링 프로토콜을 사용해서, 클라이언트는 먼저 프록시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다. 클라이언트는 이 내용을 프록시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해준다.  
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

### 참조

- HTTP 완벽 가이드
