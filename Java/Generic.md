# 제네릭(Generic)
: 컴파일 시 타입을 체크해 주는 기능

: **객체의 타입 안정성을 높이고 형 변환의 번거로움을 줄여줌(코드가 간결해짐)**
<br/>
<br/>


### 타입변수

: 클래스를 작성할 때, Object타입 대신 타입변수(E)를 선언해서 사용  
<br/>

\- 타입 변수에 대입하기  
: 객체를 생성 시, 타입 변수(E) 대신 실제 타입을 지정(대입)  
```java
ArrayList<Class> = new ArrayList<>();
```
<br/>


### **제네릭 용어**
: Box<T> ⇒ T는 타입 변수, Box는 원시타입  
```java
class Box<T>  ⇒ Box<String> b = new Box<String>(); // <>매개변수화된 타입
```
<br/>
<br/>


### **제네릭 타입의 다형성**  
: 참조 변수와 생성자의 대입 된 타입은 일치해야 한다.   
: 제네릭 클래스간 다형성은 성립(매개변수타입은 일치해야함)  
: 매개변수의 다형성도 성립  
```java
List<Tv> list = new ArrayList<Tv>();
```
<br/>
<br/>

### **Iterator\<E\>**

: 클래스를 작성할 때, Object타입 대신 T와 같은 타입 변수를 사용  
<br/>

### **HashMap**
: 여러 개의 타입 변수가 필요한 경우, 콤마(,)를 구분자로 선언  
<br/>

### **제한된 제네릭 클래스**
: extends로 대입할 수 있는 타입을 제한 (\<T extends Fruits\>)  
: 인터페이스인 경우에도 extends를 사용  
<br/>

### **제네릭의 제약**
: 타입 변수에 대입은 인스턴스 별로 다르게 가능  
: static멤버에 타입 변수 사용 불가  
```java
static T item // 에러
```  
<br/>

: 배열 생성할 때 타입 변수 사용불가. 타입 변수로 배열 선언은 가능  
: new 연산자 다음에 Type변수 사용불가  
```java
T[] arr; // 가능     T[] arr =new T[] // 불가능

```
<br/>

### **와일드 카드 \<?\>**

: 하나의 참조 변수로 대입된 타입이 다른 객체를 참조 가능  
: 메서드의 매개변수에 와일드 카드를 사용  

<br/> 

\- \<? extends T\> 와일드 카드의 상한 제한. T와 그 자손들만 가능(가장많이씀)  

\- \<? super T\> 와일드 카드의 하한 제한. T와 그 조상들만 가능  

\- \<?\> 제한 없음. 모든 타입이 가능 \<? extends Object\>와 동일  
<br/>
<br/>


### **제네릭 메서드**

: 제네릭 타입이 선언된 메서드(타입 변수는 메수드 내에서만 유효)  

: 클래스의 타입 매개변수<T>와 메서드의 타입 매개변수 <T>는 별개  

: 메서드를 호출할 때마다 타입을 대입해야 함(대부분 생략가능)  

와일드 카드는 하나의 참조변수로 서로 다른 타입이 대입된 여러 제네릭 객체를 다루기 위한 것  

제네릭 메서드는 메서드를 호출할 때마다 다른 제네릭 타입을 대입할 수 있게 한 것  
<br/>
<br/>

### **제네릭 타입의 형변환**

: 제네릭 타입과 원시 타입 간의 형변환은 바람직 하지 않다.(경고 발생)  

: 와일드 카드가 사용된 제네릭 타입으로는 형변환 가능  
<br/>
<br/>

### **제네릭 타입의 제거**

: **컴파일러는 제네릭 타입을 제거하고, 필요한 곳에 형변환을 넣는다.**  

1) 제네릭 타입의 경계(bound)를 제거  

2) 제네릭 타입 제거 후에 타입이 불일치하면, 형변환을 추가  

3) 와일드 카드가 포함된 경우, 적적한 타입으로 형변환 추가  
<br/>
<br/>